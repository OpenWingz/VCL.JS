Raphael.el.popup = function (e, t, n, r) { var i = this.paper || this[0].paper, s, o, u, a, f; if (!i) return; switch (this.type) { case "text": case "circle": case "ellipse": u = true; break; default: u = false } e = e == null ? "up" : e; t = t || 5; s = this.getBBox(); n = typeof n == "number" ? n : u ? s.x + s.width / 2 : s.x; r = typeof r == "number" ? r : u ? s.y + s.height / 2 : s.y; a = Math.max(s.width / 2 - t, 0); f = Math.max(s.height / 2 - t, 0); this.translate(n - s.x - (u ? s.width / 2 : 0), r - s.y - (u ? s.height / 2 : 0)); s = this.getBBox(); var l = { up: ["M", n, r, "l", -t, -t, -a, 0, "a", t, t, 0, 0, 1, -t, -t, "l", 0, -s.height, "a", t, t, 0, 0, 1, t, -t, "l", t * 2 + a * 2, 0, "a", t, t, 0, 0, 1, t, t, "l", 0, s.height, "a", t, t, 0, 0, 1, -t, t, "l", -a, 0, "z"].join(","), down: ["M", n, r, "l", t, t, a, 0, "a", t, t, 0, 0, 1, t, t, "l", 0, s.height, "a", t, t, 0, 0, 1, -t, t, "l", -(t * 2 + a * 2), 0, "a", t, t, 0, 0, 1, -t, -t, "l", 0, -s.height, "a", t, t, 0, 0, 1, t, -t, "l", a, 0, "z"].join(","), left: ["M", n, r, "l", -t, t, 0, f, "a", t, t, 0, 0, 1, -t, t, "l", -s.width, 0, "a", t, t, 0, 0, 1, -t, -t, "l", 0, -(t * 2 + f * 2), "a", t, t, 0, 0, 1, t, -t, "l", s.width, 0, "a", t, t, 0, 0, 1, t, t, "l", 0, f, "z"].join(","), right: ["M", n, r, "l", t, -t, 0, -f, "a", t, t, 0, 0, 1, t, -t, "l", s.width, 0, "a", t, t, 0, 0, 1, t, t, "l", 0, t * 2 + f * 2, "a", t, t, 0, 0, 1, -t, t, "l", -s.width, 0, "a", t, t, 0, 0, 1, -t, -t, "l", 0, -f, "z"].join(",") }; o = { up: { x: -!u * (s.width / 2), y: -t * 2 - (u ? s.height / 2 : s.height) }, down: { x: -!u * (s.width / 2), y: t * 2 + (u ? s.height / 2 : s.height) }, left: { x: -t * 2 - (u ? s.width / 2 : s.width), y: -!u * (s.height / 2) }, right: { x: t * 2 + (u ? s.width / 2 : s.width), y: -!u * (s.height / 2) } }[e]; this.translate(o.x, o.y); return i.path(l[e]).attr({ fill: "#000", stroke: "none" }).insertBefore(this.node ? this : this[0]) }; Raphael.el.tag = function (e, t, n, r) { var i = 3, s = this.paper || this[0].paper; if (!s) return; var o = s.path().attr({ fill: "#000", stroke: "#000" }), u = this.getBBox(), a, f, l, c; switch (this.type) { case "text": case "circle": case "ellipse": l = true; break; default: l = false } e = e || 0; n = typeof n == "number" ? n : l ? u.x + u.width / 2 : u.x; r = typeof r == "number" ? r : l ? u.y + u.height / 2 : u.y; t = t == null ? 5 : t; f = .5522 * t; if (u.height >= t * 2) { o.attr({ path: ["M", n, r + t, "a", t, t, 0, 1, 1, 0, -t * 2, t, t, 0, 1, 1, 0, t * 2, "m", 0, -t * 2 - i, "a", t + i, t + i, 0, 1, 0, 0, (t + i) * 2, "L", n + t + i, r + u.height / 2 + i, "l", u.width + 2 * i, 0, 0, -u.height - 2 * i, -u.width - 2 * i, 0, "L", n, r - t - i].join(",") }) } else { a = Math.sqrt(Math.pow(t + i, 2) - Math.pow(u.height / 2 + i, 2)); o.attr({ path: ["M", n, r + t, "c", -f, 0, -t, f - t, -t, -t, 0, -f, t - f, -t, t, -t, f, 0, t, t - f, t, t, 0, f, f - t, t, -t, t, "M", n + a, r - u.height / 2 - i, "a", t + i, t + i, 0, 1, 0, 0, u.height + 2 * i, "l", t + i - a + u.width + 2 * i, 0, 0, -u.height - 2 * i, "L", n + a, r - u.height / 2 - i].join(",") }) } e = 360 - e; o.rotate(e, n, r); if (this.attrs) { this.attr(this.attrs.x ? "x" : "cx", n + t + i + (!l ? this.type == "text" ? u.width : 0 : u.width / 2)).attr("y", l ? r : r - u.height / 2); this.rotate(e, n, r); e > 90 && e < 270 && this.attr(this.attrs.x ? "x" : "cx", n - t - i - (!l ? u.width : u.width / 2)).rotate(180, n, r) } else { if (e > 90 && e < 270) { this.translate(n - u.x - u.width - t - i, r - u.y - u.height / 2); this.rotate(e - 180, u.x + u.width + t + i, u.y + u.height / 2) } else { this.translate(n - u.x + t + i, r - u.y - u.height / 2); this.rotate(e, u.x - t - i, u.y + u.height / 2) } } return o.insertBefore(this.node ? this : this[0]) }; Raphael.el.drop = function (e, t, n) { var r = this.getBBox(), i = this.paper || this[0].paper, s, o, u, a, f; if (!i) return; switch (this.type) { case "text": case "circle": case "ellipse": s = true; break; default: s = false } e = e || 0; t = typeof t == "number" ? t : s ? r.x + r.width / 2 : r.x; n = typeof n == "number" ? n : s ? r.y + r.height / 2 : r.y; o = Math.max(r.width, r.height) + Math.min(r.width, r.height); u = i.path(["M", t, n, "l", o, 0, "A", o * .4, o * .4, 0, 1, 0, t + o * .7, n - o * .7, "z"]).attr({ fill: "#000", stroke: "none" }).rotate(22.5 - e, t, n); e = (e + 90) * Math.PI / 180; a = t + o * Math.sin(e) - (s ? 0 : r.width / 2); f = n + o * Math.cos(e) - (s ? 0 : r.height / 2); this.attrs ? this.attr(this.attrs.x ? "x" : "cx", a).attr(this.attrs.y ? "y" : "cy", f) : this.translate(a - r.x, f - r.y); return u.insertBefore(this.node ? this : this[0]) }; Raphael.el.flag = function (e, t, n) { var r = 3, i = this.paper || this[0].paper; if (!i) return; var s = i.path().attr({ fill: "#000", stroke: "#000" }), o = this.getBBox(), u = o.height / 2, a; switch (this.type) { case "text": case "circle": case "ellipse": a = true; break; default: a = false } e = e || 0; t = typeof t == "number" ? t : a ? o.x + o.width / 2 : o.x; n = typeof n == "number" ? n : a ? o.y + o.height / 2 : o.y; s.attr({ path: ["M", t, n, "l", u + r, -u - r, o.width + 2 * r, 0, 0, o.height + 2 * r, -o.width - 2 * r, 0, "z"].join(",") }); e = 360 - e; s.rotate(e, t, n); if (this.attrs) { this.attr(this.attrs.x ? "x" : "cx", t + u + r + (!a ? this.type == "text" ? o.width : 0 : o.width / 2)).attr("y", a ? n : n - o.height / 2); this.rotate(e, t, n); e > 90 && e < 270 && this.attr(this.attrs.x ? "x" : "cx", t - u - r - (!a ? o.width : o.width / 2)).rotate(180, t, n) } else { if (e > 90 && e < 270) { this.translate(t - o.x - o.width - u - r, n - o.y - o.height / 2); this.rotate(e - 180, o.x + o.width + u + r, o.y + o.height / 2) } else { this.translate(t - o.x + u + r, n - o.y - o.height / 2); this.rotate(e, o.x - u - r, o.y + o.height / 2) } } return s.insertBefore(this.node ? this : this[0]) }; Raphael.el.label = function () { var e = this.getBBox(), t = this.paper || this[0].paper, n = Math.min(20, e.width + 10, e.height + 10) / 2; if (!t) return; return t.rect(e.x - n / 2, e.y - n / 2, e.width + n, e.height + n, n).attr({ stroke: "none", fill: "#000" }).insertBefore(this.node ? this : this[0]) }; Raphael.el.blob = function (e, t, n) { var r = this.getBBox(), i = Math.PI / 180, s = this.paper || this[0].paper, o, u, a; if (!s) return; switch (this.type) { case "text": case "circle": case "ellipse": u = true; break; default: u = false } o = s.path().attr({ fill: "#000", stroke: "none" }); e = (+e + 1 ? e : 45) + 90; a = Math.min(r.height, r.width); t = typeof t == "number" ? t : u ? r.x + r.width / 2 : r.x; n = typeof n == "number" ? n : u ? r.y + r.height / 2 : r.y; var f = Math.max(r.width + a, a * 25 / 12), l = Math.max(r.height + a, a * 25 / 12), c = t + a * Math.sin((e - 22.5) * i), h = n + a * Math.cos((e - 22.5) * i), p = t + a * Math.sin((e + 22.5) * i), d = n + a * Math.cos((e + 22.5) * i), v = (p - c) / 2, m = (d - h) / 2, g = f / 2, y = l / 2, b = -Math.sqrt(Math.abs(g * g * y * y - g * g * m * m - y * y * v * v) / (g * g * m * m + y * y * v * v)), w = b * g * m / y + (p + c) / 2, E = b * -y * v / g + (d + h) / 2; o.attr({ x: w, y: E, path: ["M", t, n, "L", p, d, "A", g, y, 0, 1, 1, c, h, "z"].join(",") }); this.translate(w - r.x - r.width / 2, E - r.y - r.height / 2); return o.insertBefore(this.node ? this : this[0]) }; Raphael.fn.label = function (e, t, n) { var r = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return r.push(n.label(), n) }; Raphael.fn.popup = function (e, t, n, r, i) { var s = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return s.push(n.popup(r, i), n) }; Raphael.fn.tag = function (e, t, n, r, i) { var s = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return s.push(n.tag(r, i), n) }; Raphael.fn.flag = function (e, t, n, r) { var i = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return i.push(n.flag(r), n) }; Raphael.fn.drop = function (e, t, n, r) { var i = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return i.push(n.drop(r), n) }; Raphael.fn.blob = function (e, t, n, r) { var i = this.set(); n = this.text(e, t, n).attr(Raphael.g.txtattr); return i.push(n.blob(r), n) }; Raphael.el.lighter = function (e) { e = e || 2; var t = [this.attrs.fill, this.attrs.stroke]; this.fs = this.fs || [t[0], t[1]]; t[0] = Raphael.rgb2hsb(Raphael.getRGB(t[0]).hex); t[1] = Raphael.rgb2hsb(Raphael.getRGB(t[1]).hex); t[0].b = Math.min(t[0].b * e, 1); t[0].s = t[0].s / e; t[1].b = Math.min(t[1].b * e, 1); t[1].s = t[1].s / e; this.attr({ fill: "hsb(" + [t[0].h, t[0].s, t[0].b] + ")", stroke: "hsb(" + [t[1].h, t[1].s, t[1].b] + ")" }); return this }; Raphael.el.darker = function (e) { e = e || 2; var t = [this.attrs.fill, this.attrs.stroke]; this.fs = this.fs || [t[0], t[1]]; t[0] = Raphael.rgb2hsb(Raphael.getRGB(t[0]).hex); t[1] = Raphael.rgb2hsb(Raphael.getRGB(t[1]).hex); t[0].s = Math.min(t[0].s * e, 1); t[0].b = t[0].b / e; t[1].s = Math.min(t[1].s * e, 1); t[1].b = t[1].b / e; this.attr({ fill: "hsb(" + [t[0].h, t[0].s, t[0].b] + ")", stroke: "hsb(" + [t[1].h, t[1].s, t[1].b] + ")" }); return this }; Raphael.el.resetBrightness = function () { if (this.fs) { this.attr({ fill: this.fs[0], stroke: this.fs[1] }); delete this.fs } return this }; (function () { var e = ["lighter", "darker", "resetBrightness"], t = ["popup", "tag", "flag", "label", "drop", "blob"]; for (var n in t) (function (e) { Raphael.st[e] = function () { return Raphael.el[e].apply(this, arguments) } })(t[n]); for (var n in e) (function (e) { Raphael.st[e] = function () { for (var t = 0; t < this.length; t++) { this[t][e].apply(this[t], arguments) } return this } })(e[n]) })(); Raphael.g = { shim: { stroke: "none", fill: "#000", "fill-opacity": 0 }, txtattr: { font: "10px Arial, sans-serif", fill: "#fff" }, colors: function () { var e = [.6, .2, .05, .1333, .75, 0], t = []; for (var n = 0; n < 10; n++) { if (n < e.length) { t.push("hsb(" + e[n] + ",.75, .75)") } else { t.push("hsb(" + e[n - e.length] + ", 1, .5)") } } return t }(), snapEnds: function (e, t, n) { function s(e) { return Math.abs(e - .5) < .25 ? ~~e + .5 : Math.round(e) } var r = e, i = t; if (r == i) { return { from: r, to: i, power: 0 } } var o = (i - r) / n, u = ~~o, a = u, f = 0; if (u) { while (a) { f--; a = ~~(o * Math.pow(10, f)) / Math.pow(10, f) } f++ } else { if (o == 0 || !isFinite(o)) { f = 1 } else { while (!u) { f = f || 1; u = ~~(o * Math.pow(10, f)) / Math.pow(10, f); f++ } } f && f-- } i = s(t * Math.pow(10, f)) / Math.pow(10, f); if (i < t) { i = s((t + .5) * Math.pow(10, f)) / Math.pow(10, f) } r = s((e - (f > 0 ? 0 : .5)) * Math.pow(10, f)) / Math.pow(10, f); return { from: r, to: i, power: f } }, axis: function (e, t, n, r, i, s, o, u, a, f, l) { f = f == null ? 2 : f; a = a || "t"; s = s || 10; l = arguments[arguments.length - 1]; var c = a == "|" || a == " " ? ["M", e + .5, t, "l", 0, .001] : o == 1 || o == 3 ? ["M", e + .5, t, "l", 0, -n] : ["M", e, t + .5, "l", n, 0], h = this.snapEnds(r, i, s), p = h.from, d = h.to, v = h.power, m = 0, g = { font: "11px 'Fontin Sans', Fontin-Sans, sans-serif" }, y = l.set(), b = l.set(), w; w = (d - p) / s; var E = p, S = v > 0 ? v : 0; C = n / s; if (+o == 1 || +o == 3) { var x = t, T = (o - 1 ? 1 : -1) * (f + 3 + !!(o - 1)); while (x >= t - n) { a != "-" && a != " " && (c = c.concat(["M", e - (a == "+" || a == "|" ? f : !(o - 1) * f * 2), x + .5, "l", f * 2 + 1, 0])); y.push(l.text(e + T, x, u && u[m++] || (Math.round(E) == E ? E : +E.toFixed(S))).attr(g).attr({ "text-anchor": o - 1 ? "start" : "end" })); E += w; x -= C } if (Math.round(x + C - (t - n))) { a != "-" && a != " " && (c = c.concat(["M", e - (a == "+" || a == "|" ? f : !(o - 1) * f * 2), t - n + .5, "l", f * 2 + 1, 0])); y.push(l.text(e + T, t - n, u && u[m] || (Math.round(E) == E ? E : +E.toFixed(S))).attr(g).attr({ "text-anchor": o - 1 ? "start" : "end" })) } } else { E = p; S = (v > 0) * v; T = (o ? -1 : 1) * (f + 9 + !o); var N = e, C = n / s, k = 0, L = 0; while (N <= e + n) { var A = t - (a == "+" ? f : !!o * f * 2); a != "-" && a != " " && (c = c.concat(["M", N + .5, A, "l", 0, f * 2 + 1])); y.push(k = l.text(N, t + T, u && u[m++] || (Math.round(E) == E ? E : +E.toFixed(S))).attr(g)); var O = k.getBBox(); if (L >= O.x - 5) { y.pop(y.length - 1).remove() } else { L = O.x + O.width } E += w; N += C } if (Math.round(N - C - e - n)) { a != "-" && a != " " && (c = c.concat(["M", e + n + .5, t - (a == "+" ? f : !!o * f * 2), "l", 0, f * 2 + 1])); y.push(l.text(e + n, t + T, u && u[m] || (Math.round(E) == E ? E : +E.toFixed(S))).attr(g)) } } var M = l.path(c); M.text = y; M.all = l.set([M, y]); M.remove = function () { this.text.remove(); this.constructor.prototype.remove.call(this) }; return M }, labelise: function (e, t, n) { if (e) { return (e + "").replace(/(##+(?:\.#+)?)|(%%+(?:\.%+)?)/g, function (e, r, i) { if (r) { return (+t).toFixed(r.replace(/^#+\.?/g, "").length) } if (i) { return (t * 100 / n).toFixed(i.replace(/^%+\.?/g, "").length) + "%" } }) } else { return (+t).toFixed(0) } } }