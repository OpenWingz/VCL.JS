(function () { function t(t, n, r, i, s, o, u, a, f, l) { function c(e, o) { +e[0] && (e[0] = h.axis(n, r + o[0], i - 2 * o[0], d, v, l.axisxstep || Math.floor((i - 2 * o[0]) / 20), 2, l.axisxlabels || null, l.axisxtype || "t", null, t)); +e[1] && (e[1] = h.axis(n + i, r + s - o[1], s - 2 * o[1], y, b, l.axisystep || Math.floor((s - 2 * o[1]) / 20), 3, l.axisylabels || null, l.axisytype || "t", null, t)); +e[2] && (e[2] = h.axis(n + o[3], r + s - o[2] + M, i - o[3] - m - M, d, v, l.axisxstep || Math.floor((i - 2 * o[2]) / 20), 0, l.axisxlabels || null, l.axisxtype || "t", null, t)); +e[3] && (e[3] = h.axis(n + o[3] - M, r + s - o[2], s - o[2] - m - M, y, b, l.axisystep || Math.floor((s - 2 * o[3]) / 20), 1, l.axisylabels || null, l.axisytype || "t", null, t)) } l = l || {}; var h = this; var p = h.snapEnds(Math.min.apply(Math, o), Math.max.apply(Math, o), o.length - 1), d = p.from, v = p.to, m = l.gutter || 14, g = h.snapEnds(Math.min.apply(Math, u), Math.max.apply(Math, u), u.length - 1), y = g.from, b = g.to, w = Math.max(o.length, u.length, a.length), E = t[l.symbol] || "circle", S = t.set(), x = t.set(), T = l.max || 100, N = Math.max.apply(Math, a), C = [], k = Math.sqrt(N / Math.PI) * 2 / T, L = l.colors || h.colors; for (var A = 0; A < w; A++) { C[A] = Math.max(Math.min(Math.sqrt(a[A] / Math.PI) * 2 / k, T), 3) } var O = t.set(), M = Math.max.apply(Math, C); if (l.axis) { var _ = (l.axis + "").split(/[,\s]+/); var D = [m, m, m, m]; c.call(h, _, D); var P = []; for (var A = 0, H = _.length; A < H; A++) { var B = _[A].all ? _[A].all.getBBox()[["height", "width"][A % 2]] : 0; D[A] = B + m; P[A] = B } for (var A = 0, H = _.length; A < H; A++) if (_[A].all) { _[A].remove(); _[A] = 1 } if (l.titleX) D[2] += 10; if (l.titleY) D[3] += 10; c.call(h, _, D); if (l.titleX) t.text(i / 2, s + 5, l.titleX).attr("font-size", l.gridTextSize).attr("font-family", l.gridTextFamily).attr("font-weight", l.gridTitleWeight || "normal").attr("fill", l.gridTextColor); if (l.titleY) t.text(5, s / 2, l.titleY).attr("font-size", l.gridTextSize).attr("font-family", l.gridTextFamily).attr("font-weight", l.gridTitleWeight || "normal").attr("fill", l.gridTextColor).rotate(270); for (var A = 0, H = _.length; A < H; A++) if (_[A].all) { O.push(_[A].all) } S.axis = O } var j = (i - D[3] - M - m) / (v - d || 1), F = (s - D[2] - m - M) / (b - y || 1); if (l.horizgridline > 0) for (var A = y; A <= b; A++) { var I = r + s - D[2] - (A - y) * F; var q = n + D[3] + 0 * j; var R = n + D[3] + (v - d) * j; t.path(["M", q, I, "L", R, I]).attr({ stroke: l.gridlinecolor, "stroke-dasharray": "-", "stroke-width": l.horizgridline }).toBack(); } if (l.vertgridline > 0) for (var A = d; A <= v; A++) { var U = n + D[3] + (A - d) * j; var z = r + D[2] + 0 * F; var W = r + D[2] + (b - y) * F; t.path(["M", U, z, "L", U, W]).attr({ stroke: l.gridlinecolor, "stroke-dasharray": "-", "stroke-width": l.vertgridline }).toBack(); } for (var A = 0, H = u.length; A < H; A++) { var X = t.raphael.is(E, "array") ? E[A] : E; var U = n + D[3] + (o[A] - d) * j; var I = r + s - D[2] - (u[A] - y) * F; X && C[A] && x.push(t[X](U, I, C[A]).attr({ fill: l.heat ? e(C[A], M) : L[0], "fill-opacity": l.opacity ? C[A] / T : 1, stroke: "none" })) } var V = t.set(); for (var A = 0, H = u.length; A < H; A++) { var U = n + D[3] + (o[A] - d) * j, I = r + s - D[2] - (u[A] - y) * F; V.push(t.circle(U, I, M).attr(h.shim)); l.href && l.href[A] && V[A].attr({ href: l.href[A] }); var $ = +C[A].toFixed(3); V[A].r = $; V[A].x = +U.toFixed(3); V[A].y = +I.toFixed(3); V[A].X = o[A]; V[A].Y = u[A]; V[A].value = a[A] || 0; V[A].dot = x[A]; V[A].obj = f[A] } S.covers = V; S.series = x; S.push(x, O, V); S.hover = function (e, t) { V.mouseover(e).mouseout(t); return this }; S.click = function (e) { V.click(e); return this }; S.each = function (e) { if (!t.raphael.is(e, "function")) { return this } for (var n = V.length; n--;) { e.call(V[n]) } return this }; S.href = function (e) { var t; for (var n = V.length; n--;) { t = V[n]; if (t.X == e.x && t.Y == e.y && t.value == e.value) { t.attr({ href: e.href }) } } }; return S } var e = function (e, t, n, r) { return "hsb(" + [Math.min((1 - e / t) * .4, 1), n || .75, r || .75] + ")" }; var n = function () { }; n.prototype = Raphael.g; t.prototype = new n; Raphael.fn.dotchart = function (e, n, r, i, s, o, u, a, f) { return new t(this, e, n, r, i, s, o, u, a, f) } })()